# 472. Concatenated Words

Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.

A **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.

&#x20;

**Example 1:**

<pre><code><strong>Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
</strong><strong>Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
</strong><strong>Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; 
</strong>"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
</code></pre>

**Example 2:**

<pre><code><strong>Input: words = ["cat","dog","catdog"]
</strong><strong>Output: ["catdog"]
</strong></code></pre>

```
class Solution {
public List<String> findAllConcatenatedWordsInADict(String[] words) {
 //sort the array in asc order of word length, since longer words are formed by shorter words.
 Arrays.sort(words, (a,b) -> a.length() - b.length());

  List<String> result = new ArrayList<>();

  //list of shorter words 
  HashSet<String> preWords = new HashSet<>();

  for(int i=0; i< words.length; i++){
      //Word Break-I problem.
      if(topDown(words[i], preWords, 0, new Boolean[words[i].length()])) {
          result.add(words[i]);
      }
      preWords.add(words[i]);
  }
  return result;
 }

private boolean topDown(String s, HashSet<String> wordDict, int startIndex, Boolean[] memo) {
 if(wordDict.isEmpty()) {
     return false;
 }
 // if we reach the beyond the string, then return true
 // s = "leetcode" when "code" is being checked in the IF() of the loop, we reach endIndex == s.length(), 
 // and wordDict.contains("code") => true and topDown(s, wordDict, endIndex, memo) needs to return true. 
 if(startIndex == s.length()) {
     return true;
 }
 
 // memo[i] = true means => that the substring from index i can be segmented. 
 // memo[startIndex] means => wordDict contains substring from startIndex and it can be segemented.
 if(memo[startIndex] != null) { //Boolean[] array's default value is "null"
     return memo[startIndex];
 }
 
 for(int endIndex = startIndex + 1; endIndex <= s.length(); endIndex++) {
     if(wordDict.contains(s.substring(startIndex, endIndex)) && topDown(s, wordDict, endIndex, memo)) {
         memo[startIndex] = true;
         return true;
     }
 }
 memo[startIndex] = false;
 return false;
}
} 
```
