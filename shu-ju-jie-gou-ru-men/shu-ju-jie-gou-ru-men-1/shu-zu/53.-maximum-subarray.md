# 53. Maximum Subarray

贪心：

若当前元素之前数组的和 < 0 则舍弃当前元素之前的数组

```
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}

```

DP：

若前一个元素 > 0，则将其加到当前元素上

（这样保证了指针指到每一个元素时，当前元素都是从左边起和最大的元素，因为负的没有加，有正数就加上了。这样遍历完整个数组后，最大的元素即是所求元素）

这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字 如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果 时间复杂度：O(n)O(n) 代码 JavaJavaScript



```
int maxSubArray3(std::vector<int> &nums) {
    assert(!nums.empty());

    int n = nums.size();
    int maxSum = nums[0];

    // 如果当前值小于0，
    // 重新开始(全局最大值更新)
    for (int i = 1; i < n; i++) {
        // 更新当前的最大值
        if (nums[i - 1] > 0) {
            nums[i] += nums[i - 1];
        }
        // 更新全局的最大值
        maxSum = std::max(nums[i], maxSum);
    }

    return maxSum;
}

```
