# 53. Maximum Subarray

贪心：

若当前元素之前数组的和 < 0 则舍弃当前元素之前的数组

若前当前元素之前数组的和 > 0，则将其加到当前元素上

（这样保证了指针指到每一个元素时，当前元素都是从左边起和最大的元素，因为负的没有加，有正数就加上了。这样遍历完整个数组后，最大的元素即是所求元素）

```
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;
        for(int num: nums) {
            if(sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    }
}

```



The thought follows a simple rule:&#x20;

If the sum of a subarray is positive, it has possible to make the next value bigger, so we keep do it until it turn to negative.&#x20;

If the sum is negative, it has no use to the next element, so we break.&#x20;

it is a game of sum, not the elements.

```
int maxSubArray3(std::vector<int> &nums) {
    assert(!nums.empty());

    int n = nums.size();
    int maxSum = nums[0];

    // 如果当前值小于0，
    // 重新开始(全局最大值更新)
    for (int i = 1; i < n; i++) {
        // 更新当前的最大值
        if (nums[i - 1] > 0) {
            nums[i] += nums[i - 1];
        }
        // 更新全局的最大值
        maxSum = std::max(nums[i], maxSum);
    }

    return maxSum;
}

```

DP:



```
public int maxSubArray(int[] A) {
        int n = A.length;
        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];
        dp[0] = A[0];
        int max = dp[0];
        
        for(int i = 1; i < n; i++){
            dp[i] = Math.max(A[i] + dp[i - 1] , A[i]);
            max = Math.max(max, dp[i]);
        }
        
        return max;
}
```
